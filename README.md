# vivacity-proto-buffet
Public-access repo with Vivacity's protobuf message schema

## Introduction
This is a schema for exchanging data on detection of objects on roads (eg cars, pedestrians, cyclists).

This schema is made publically available to encourage cross-industry collaboration and open exchange of data. It is also intended to:
- Assist consumers of detection data by ensuring some degree of interoperability between various sources which supply the data
- Allow new suppliers of data sources (eg detectors) to enter the market through access to an agreed-upon specification.
- Provide purchasers of future detection capabilities an easier route to procuring and understanding interoperability
- Cover current and future technologies.
- Facilitate collaboration by being open-source and extensible.

## Why Use Protobuf?
Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data. Compilers to create source code for handling these messages are available for all popular programming langages.

More information on protocol buffers can be found here:
https://developers.google.com/protocol-buffers

Serialisation ensures that messages are compact, saving bandwidth. The structured nature of the schemas, and their ease of extensibility makes collaboration and updates simple.

The job of packing and unpacking data for transmission is handled automatically by source code generated by the protobuf complier. This means effort can be focussed on the application producing or consuming the data, rather than the "nuts and bolts" of messaging and transmission.

The protobuf tutorials are an excellent way to understand how to use these schemas:
https://developers.google.com/protocol-buffers/docs/tutorials

## Supported Languages <a name="supported"></a>
Generating protobuf classes should be as simple as calling, from the project root directory:
```bash
./generate_<language>.sh
```
If a custom file path to store the generated proto classes is required, call:
```bash
./generate_<language>.sh custom/path/for/generated/proto/classes
```
This should generate a folder called `vivacity` with the `*.proto` files and generated protobuf classes in your specified folder. e.g. for golang:
```bash
└── vivacity-proto-buffet
    ├── core
    │   ├── alerts.pb.go
    │   ├── alerts.proto
    │   ├── classifying_detector_class_types.pb.go
    │   ├── classifying_detector_class_types.proto
    |   ├── ...
    |   └── ...
```
### **All Languages Requirements**:
* protoc >= v3.11.0
#### **<u>Go</u>** <a name="golang"></a>
* protoc-gen-go >= 1.4.0:
    * **Required**. Install by running `go get -u github.com/golang/protobuf/protoc-gen-go`
#### **<u>Python</u>** <a name="python"></a>
* Optional **grpc support** - allows script to call `python -m grpc_tools.protoc` and generates `*_pb2_grpc.py` files. `requirements.txt` is given below:
  ```txt
  grpcio
  protobuf==3.11.0
  grpcio-tools
  ```

#### **<u>Javascript / Typescript</u>** <a name="js-ts"></a>
* `ts-protoc-gen` >= 0.12.0
    * **Required**. Install with `yarn add ts-protoc-gen`

## Vivacity Message Schema
![alt text](docs/images/dtf.png "Detector tracker frame message structure")

## Message Types
### Summary
The protobuf schema organises messages into a hierarchy which is visualised graphically in the image above. Protobuf permits fields not marked as `required` to be omitted. Therefore even though the schema has a relatively deep "tree" of nested messages, it is possible to send relatively concise messages if only particular features are required.

Depending upon the use case, one or more nested messages may be sent, with a variety of fields populated.

## Message Descriptions
### Detector Tracker Frame
As can be seen graphically in the image above, the Detector Tracker Frame (DTF) is the outermost message type. It is the fundamental output of the Vivacity computer vision system and contains most other important messages types within it.

It contains both important engineering values (zonal occupancy, detection classification, object position etc) as well as metadata such as the id of the sending system and timestamp.

The Vivacity computer vision system emits one DTF for every "frame" of video which is processed. A typical Vivacity sensor might run at 15 frames per second, with all detection inference and processing being performed immediately after a frame is captured. 15 times per second a DTF is emitted, populated with all the features which are enabled on that sensor. 

Description of key fields: 

- `frame_time_microseconds`: Unix time that the frame was processed, measured in microseconds
- `vision_program_id`: Unique identifier of the "vision program" that emitted this DTF. Note: multiple computer vision programs may run on a single piece of hardware - so this is not necessarily the unique ID of the hardware.
- `track_heads`: a list of Track Head messages, one for each tracked object within view (see below)
- `zone_oriented_features` a list of Zonal Features messages, one for each zone configured (see below)

### Track Head
The Vivacity Sensor tracks detected object through its field of view. A track is made up of multiple individual detections - the most recent is known as the Track Head - and can be assumed to contain the most up to date information about the detected object, eg: its current location. 

Key fields:
- `detection_box`: A `DetectionBox` message containing information about the position of the detected object.
- `track_number`: A unique ID for the detected object that lasts for the lifetime of the object within the field of view. 
- `is_predicted`: A flag indicating whether the computer vision system is predicting this Track Head and not directly observing it. For example, may be set `true` if an object is temporarily occluded by another object passing in-front of it - causing the sensor to momentarily lose sight of it.
- `last_detected_timestamp_microseconds`: if `is_predicted` is `true`, this is the timestamp of the previous non-predicted detection of the object.
- `occupancy_zone_id`: a list of the zones that the object is currently within.
- `countline_crossings`: a list of the countlines that the track has crossed since it was first instantiated.
- `frame_time_microseconds`

## Use cases
